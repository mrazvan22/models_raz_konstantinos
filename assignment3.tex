\documentclass[11pt,a4paper,oneside]{report}
\usepackage{amsmath,amssymb,calc,ifthen}
\usepackage{float}
%\usepackage{cancel}
\usepackage[table,usenames,dvipsnames]{xcolor} % for coloured cells in tables
\usepackage{tikz}
% Allows us to click on links and references!
\usepackage{hyperref}
\usepackage{url}
\hypersetup{
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black
}
% Nice package for plotting graphs
% See excellent guide:
% http://www.tug.org/TUGboat/tb31-1/tb97wright-pgfplots.pdf
\usetikzlibrary{plotmarks}
\usepackage{amsmath,graphicx}
\usepackage{epstopdf}
\usepackage{caption}
\usepackage{subcaption}
% highlight - useful for TODOs and similar
\usepackage{color}
\newcommand{\hilight}[1]{\colorbox{yellow}{#1}}
\newcommand\ci{\perp\!\!\!\perp} % perpendicular sign
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}} % diagonal fraction
\newcommand\SLASH{\char`\\}
\usepackage{listings}
% margin size
\usepackage[margin=1in]{geometry}
\tikzstyle{state}=[circle,thick,draw=black, align=center, minimum size=2.1cm,
inner sep=0]
\tikzstyle{vertex}=[circle,thick,draw=black]
\tikzstyle{terminal}=[rectangle,thick,draw=black]
\tikzstyle{edge} = [draw,thick]
\tikzstyle{lo} = [edge,dotted]
\tikzstyle{hi} = [edge]
\tikzstyle{trans} = [edge,->]
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add
%\usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the
%code
breakatwhitespace=false, % sets if automatic breaks should only happen
%at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the
%given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for
%8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping
%indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible
%values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed
%on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular
%underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular
%underscores
stepnumber=2, % the step between two line-numbers. If it's
%1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with
%\lstinputlisting; also try caption instead of title
}
\title{Graphical Models Coursework 3}
\author{
Razvan Valentin Marinescu\\
Student Number: 14060166\\
\texttt{razvan.marinescu.14@ucl.ac.uk}
\and
Konstantinos Georgiadis\\
Student Number: 14110861\\
\texttt{konstantinos.georgiadis.14@ucl.ac.uk}
}
\begin{document}
\belowdisplayskip=12pt plus 3pt minus 9pt
\belowdisplayshortskip=7pt plus 3pt minus 4pt
\maketitle{}

Just as in the previous assignment, we both did the exercises independently and compared our answers until we agreed on what to choose. Konstantinos wrote most of the report and Razvan added some changes afterwards.

\section*{Problem 7.4}

We changed the code from demoMDP accordingly for this exercise and we only kept the Value Iteration strategy. We kept the value of gamma to be the same as it was (0.95), as well as the number of iterations to be 30. Our code then proceeds to make moves by moving at each timestep to the neighboring grid position with the highest value and stops once it reaches a point where the grid position that the airplane currently occupies has a higher value than its neighboring grid positions. For the second part of the exercise, we merely had to change the p matrix accordingly. The optimal paths are given from the variable PositionSequence. In the first case, the optimal path is:\\\\
X Y\\
1     13\\
     1    12\\
     1    11\\
     2    11\\
     3    11\\
     4    11\\
     5    11\\
     6    11\\
     7    11\\
     8    11\\
     9    11\\
    10    11\\
    11    11\\
    12    11\\
    13    11\\
    14    11\\
    15    11\\
    15    10\\
    15     9\\
    14     9\\
    14     8\\
    14     7\\
    13     7\\
    12     7\\
    11     7\\
    10     7\\
     9     7\\
     8     7\\
     7     7\\
     6     7\\
     5     7\\
     4     7\\
     4     6\\
     4     5\\
     4     4\\
     5     4\\
     6     4\\
     7     4\\
     8     4\\\\
     
In the second case, the optimal path is:\\\\
X Y\\     
     1    13\\
     1    14\\
     2    14\\
     3    14\\
     4    14\\
     5    14\\
     6    14\\
     7    14\\
     8    14\\
     9    14\\
    10    14\\
    11    14\\
    12    14\\
    13    14\\
    14    14\\
    15    14\\
    16    14\\
    16    13\\
    16    12\\
    16    11\\
    15    11\\
    15    10\\
    15     9\\
    14     9\\
    14     8\\
    14     7\\
    13     7\\
    12     7\\
    11     7\\
    10     7\\
     9     7\\
     8     7\\
     7     7\\
     6     7\\
     5     7\\
     4     7\\
     4     6\\
     4     5\\
     4     4\\
     5     4\\
     6     4\\
     7     4\\
     8     4\\\\
     
     This result can be explained in the sense that the value iteration method makes use of the p matrix, as well as the utility values. Since there is now a higher chance to move up, during the value iterations, the values of the path around the up-right village get higher values, rather than the path through (14,11).\\
     
     MATLAB code:
     

\begin{lstlisting}
clear all;
close all;
load('airplane.mat');
import brml.*
[Gx, Gy] = size(U);  % two dimensional grid size
S = Gx*Gy; % number of states on grid
st = reshape(1:S,Gx,Gy); % assign each grid point a state

A = 5;  % number of action (decision) states
[stay, up, down, left, right] = assign(1:A); % actions (decisions)
p = zeros(S,S,A); % initialise the transition p(xt|xtm,dtm) ie p(x(t)|x(t-1),d(t-1))

% make a deterministic transition matrix on a 2D grid:
for x = 1:Gx
	for y = 1:Gy
		p(st(x,y),st(x,y),stay)=1; % can stay in same state
		if validgridposition(x+1,y,Gx,Gy)
			p(st(x+1,y),st(x,y),right)=1;
		end
		if validgridposition(x-1,y,Gx,Gy)
			p(st(x-1,y),st(x,y),left)=1;
		end
		if validgridposition(x,y+1,Gx,Gy)
			p(st(x,y+1),st(x,y),up)=1;
		end
		if validgridposition(x,y-1,Gx,Gy)
			p(st(x,y-1),st(x,y),down)=1;
		end
	end
end
% define utilities
u = U(:);
gamma = 0.95; % discount factor
figure; imagesc(reshape(u,Gx,Gy)); colorbar; title('utilities');
[xt, xtm, dtm]=assign(1:3); % assign the variables x(t), x(t-1), d(t-1) to some numbers

% define the transition potentials p(x(t)|x(t-1),d(t-1))
tranpot=array([xt xtm dtm],p);
% setup the value potential v(x(t))
valpot=array(xt,ones(S,1)); % initial values

maxiterations=30; tol=0.001; % termination criteria
% Value Iteration:
oldvalue=valpot.table;
for valueloop=1:maxiterations
	valueloop
	tmppot = maxpot(sumpot(multpots([tranpot valpot]),xt),dtm);
	valpot.table = u + gamma*tmppot.table; % Bellman's recursion
	if mean(abs(valpot.table-oldvalue))<tol; break; end % stop if converged
	oldvalue = valpot.table;
	imagesc(reshape(valpot.table,Gx,Gy)); colorbar; drawnow
end
figure; bar3zcolor(reshape(valpot.table,Gx,Gy));

FinalValues = reshape(valpot.table,Gx,Gy);

%Calculate Optimal Sequence
PositionSequence = [1 13];
timestep = 1;
while(1)
    x = PositionSequence(timestep,1);
    y = PositionSequence(timestep,2);
    %find best move
    currentval = FinalValues(x,y);
    bestmove = stay;
    if validgridposition(x+1,y,Gx,Gy)
        if(FinalValues(x+1,y) > currentval)
            currentval = FinalValues(x+1,y);
            bestmove = right;
        end
    end
    if validgridposition(x-1,y,Gx,Gy)
        if(FinalValues(x-1,y) > currentval)
            currentval = FinalValues(x-1,y);
            bestmove = left;
        end
    end
    if validgridposition(x,y+1,Gx,Gy)
        if(FinalValues(x,y+1) > currentval)
            currentval = FinalValues(x,y+1);
            bestmove = up;
        end
    end
    if validgridposition(x,y-1,Gx,Gy)
        if(FinalValues(x,y-1) > currentval)
            currentval = FinalValues(x,y-1);
            bestmove = down;
        end
    end
    %make new move or exit
    timestep = timestep + 1;
    if(bestmove == stay)
        break;
    end
    PositionSequence(timestep,1:2) = PositionSequence(timestep-1,1:2);
    if(bestmove == right)
        PositionSequence(timestep,1) = PositionSequence(timestep,1)+1;
    end
    if(bestmove == left)
        PositionSequence(timestep,1) = PositionSequence(timestep,1)-1;
    end
    if(bestmove == up)
        PositionSequence(timestep,2) = PositionSequence(timestep,2)+1;
    end
    if(bestmove == down)
        PositionSequence(timestep,2) = PositionSequence(timestep,2)-1;
    end
end
PositionSequence



%Part 2
p = zeros(S,S,A); 
for x = 1:Gx
	for y = 1:Gy
		p(st(x,y),st(x,y),stay)=1; 
		if validgridposition(x+1,y,Gx,Gy)
            if validgridposition(x,y+1,Gx,Gy)
                p(st(x+1,y),st(x,y),right)=0.9;
                p(st(x,y+1),st(x,y),right)=0.1;
            else
                p(st(x+1,y),st(x,y),right)=1;
            end
		end
		if validgridposition(x-1,y,Gx,Gy)
			p(st(x-1,y),st(x,y),left)=1;
		end
		if validgridposition(x,y+1,Gx,Gy)
			p(st(x,y+1),st(x,y),up)=1;
		end
		if validgridposition(x,y-1,Gx,Gy)
			p(st(x,y-1),st(x,y),down)=1;
		end
	end
end
% define utilities
u = U(:);
gamma = 0.95;
figure; imagesc(reshape(u,Gx,Gy)); colorbar; title('utilities');
[xt, xtm, dtm]=assign(1:3); % assign the variables x(t), x(t-1), d(t-1) to some numbers

% define the transition potentials p(x(t)|x(t-1),d(t-1))
tranpot=array([xt xtm dtm],p);
% setup the value potential v(x(t))
valpot=array(xt,ones(S,1)); % initial values

maxiterations=30; tol=0.001; % termination criteria
% Value Iteration:
oldvalue=valpot.table;
for valueloop=1:maxiterations
	valueloop
	tmppot = maxpot(sumpot(multpots([tranpot valpot]),xt),dtm);
	valpot.table = u + gamma*tmppot.table; % Bellman's recursion
	if mean(abs(valpot.table-oldvalue))<tol; break; end % stop if converged
	oldvalue = valpot.table;
	imagesc(reshape(valpot.table,Gx,Gy)); colorbar; drawnow
end
figure; bar3zcolor(reshape(valpot.table,Gx,Gy));

FinalValues = reshape(valpot.table,Gx,Gy);

%Calculate Optimal Sequence
PositionSequence = [1 13];
timestep = 1;
while(1)
    x = PositionSequence(timestep,1);
    y = PositionSequence(timestep,2);
    %find best move
    currentval = FinalValues(x,y);
    bestmove = stay;
    if validgridposition(x+1,y,Gx,Gy)
        if(FinalValues(x+1,y) > currentval)
            currentval = FinalValues(x+1,y);
            bestmove = right;
        end
    end
    if validgridposition(x-1,y,Gx,Gy)
        if(FinalValues(x-1,y) > currentval)
            currentval = FinalValues(x-1,y);
            bestmove = left;
        end
    end
    if validgridposition(x,y+1,Gx,Gy)
        if(FinalValues(x,y+1) > currentval)
            currentval = FinalValues(x,y+1);
            bestmove = up;
        end
    end
    if validgridposition(x,y-1,Gx,Gy)
        if(FinalValues(x,y-1) > currentval)
            currentval = FinalValues(x,y-1);
            bestmove = down;
        end
    end
    %make new move or exit
    timestep = timestep + 1;
    if(bestmove == stay)
        break;
    end
    PositionSequence(timestep,1:2) = PositionSequence(timestep-1,1:2);
    if(bestmove == right)
        PositionSequence(timestep,1) = PositionSequence(timestep,1)+1;
    end
    if(bestmove == left)
        PositionSequence(timestep,1) = PositionSequence(timestep,1)-1;
    end
    if(bestmove == up)
        PositionSequence(timestep,2) = PositionSequence(timestep,2)+1;
    end
    if(bestmove == down)
        PositionSequence(timestep,2) = PositionSequence(timestep,2)-1;
    end
end
PositionSequence
\end{lstlisting}
\section*{Problem 7.13}

MATLAB function (explanation below it):

\begin{lstlisting}
function [d1, val]=optdec(epsilonA1,epsilonB1,desired,T,w1,pars)
import brml.*
eat = 1;
eatm1 = 2;
peatgeatm1=array([eat eatm1],pars.epsilonAtran);

ebt = 3;
ebtm1 = 4;
pebtgebtm1=array([ebt ebtm1],pars.epsilonBtran);

wt = 5;
wtm1 = 6;
utilitywT = pars.WealthValue;
utilitywT(utilitywT < desired*w1) = 0;
utilitywT(utilitywT >= desired*w1) = 10000;
uwT=array(wt,utilitywT);

dtm1 = 7;

pbigarray = zeros(length(pars.WealthValue),length(pars.WealthValue),length(pars.epsilonAval),length(pars.epsilonBval),length(pars.DecisionValue));
for a = 1:length(pars.WealthValue)
    previouswealth = pars.WealthValue(a);
    for b = 1:length(pars.epsilonAval)
        currentincreasea = pars.epsilonAval(b);
        for c = 1:length(pars.epsilonBval)
            currentincreaseb = pars.epsilonBval(c);
            for d = 1:length(pars.DecisionValue)
                previousdecision = pars.DecisionValue(d);
                newwealth = previouswealth*(previousdecision*(1+currentincreasea)+(1-previousdecision)*(1+currentincreaseb));
                %find closest value
                [~,diracposition] = min(abs(pars.WealthValue - newwealth));
                pbigarray(diracposition,a,b,c,d) = 1;
            end
        end
    end
end
pbig=array([wt wtm1 eat ebt dtm1],pbigarray);

multiplypots = multpots([peatgeatm1 pebtgebtm1 pbig]);
for t = T:-1:2
    if(t == T)
        messagepot = maxpot(sumpot(multpots([multiplypots uwT]),[eat ebt wt]),dtm1);
    elseif(t > 2)
        messagepot.variables = [eat ebt wt];
        messagepot = maxpot(sumpot(multpots([multiplypots messagepot]),[eat ebt wt]),dtm1);
    else
        messagepot.variables = [eat ebt wt];
        UtilityFinal = sumpot(multpots([multiplypots messagepot]),[eat ebt wt]);
    end
end
UtilityFinalGivenConds = setpot(UtilityFinal,[eatm1 ebtm1 wtm1],[epsilonA1 epsilonB1 find(w1==pars.WealthValue)]);
[~, d1] = max(UtilityFinalGivenConds.table);

%Calculate Expected Wealth Value
wealthvalues=array(wt,pars.WealthValue);
for t = 2:1:T
    if(t == T)
        messagepot.variables = [eatm1 ebtm1 wtm1];
        FinalPot = sumpot(multpots([multiplypots messagepot]),[eatm1 ebtm1 wtm1 dtm1 eat ebt]);        
        FinalPot.table = FinalPot.table/(length(pars.DecisionValue));
    elseif(t > 2)
        messagepot.variables = [eatm1 ebtm1 wtm1];
        messagepot = sumpot(multpots([multiplypots messagepot]),[eatm1 ebtm1 wtm1 dtm1]);
        messagepot.table = messagepot.table/(length(pars.DecisionValue));
    else
        messagepot = setpot(multiplypots,[eatm1 ebtm1 wtm1 dtm1],[epsilonA1 epsilonB1 find(w1==pars.WealthValue) d1]);
    end
end
ExpectedWealth = sumpot(multpots([FinalPot wealthvalues]));
val = ExpectedWealth.table;
end
\end{lstlisting}

After creating the probability tables for $p(\epsilon_t^a|\epsilon_{t-1}^a),p(\epsilon_t^b|\epsilon_{t-1}^b),p(w_t|w_{t-1},\epsilon_t^a,\epsilon_t^b,d_{t-1})$, we perform the message passing as described in equations 7.8.34-36. The optimal expected utility is: 9875.5933608406 and the optimal choice is to invest 0.25 of our wealth into asset a at the first timestep. Later on, the code calculated the expected wealth at timestep T, even though the exercise doesn't seem to ask for it, but the file exerciseInvest.m suggests it. The expected wealth at timestep 40 turns out to be: 1.4247570326108. The influence diagram is:\\
	\begin{center} \includegraphics[width=1\textwidth]{c7e13influencediagram}\end{center}
	
\section*{Problem 7.14}
In order to understand this problem and its utilities and probabilities, we need to look at it from the "player's" perspective. Once he knows that he has a 100 (or $C$ in general) pound cheque, then there are two possibilities (assuming each has equal probability of 0.5). Either the other cheque is 50 ($C/2$) pounds or 200 ($2C$) pounds. Therefore, we have the following expected utilities (where $U(high,change)$ means that the $C$ or 100 pound cheque is the one with twice the amount of the other cheque, which would be 50 pounds):\\
$$U(change) = p(high)U(high,change) + p(low)U(low,change) = 0.5\frac{C}{2} + 0.5*2C = 1.25*C$$
$$U(no\ change) = p(high)U(high,no\ change) + p(low)U(low,no\ change) = 0.5*C + 0.5*C = C$$
Therefore, it is better to change. The same applies if we know the value and it is 100, we simply replace $C = 100$. The confusion regarding this problem is that in reality the "experiment" would be set to either 50-100 or 100-200. In that case (say 50-100), if we had someone change their choice all the time, then it would make no difference. Therefore, if the "player" knew that the case was that it is 50-100, then he would never change if he knew that he got the 100 cheque and if he didn't look at the cheque, then the expected utility would be the same regardless of whether he decides to change or not. The counterintuitive thing about the solution is that, in a sense, it assumes that the experiment can be reproduced many times (as in, every time the player picks a cheque with C or 100 pounds and does not know if the other cheque is C/2 or 2C (50 or 200)), and after running it many times, the player who always changes will have more money than the one who never changes.
\section*{Problem 9.1}
\section*{Problem 9.9}
\section*{Problem 9.10}
\section*{Problem 9.13}
\section*{Problem 10.3}
\section*{Problem 10.5}


\end{document}





















